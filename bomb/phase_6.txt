 1│ Dump of assembler code for function phase_6:     
 2│    0x00000000004010f4 <+0>:     push   %r14                           
 3│    0x00000000004010f6 <+2>:     push   %r13      
 4│    0x00000000004010f8 <+4>:     push   %r12      
 5│    0x00000000004010fa <+6>:     push   %rbp                                   
 6│    0x00000000004010fb <+7>:     push   %rbx      
 7│    0x00000000004010fc <+8>:     sub    $0x50,%rsp
 8│    0x0000000000401100 <+12>:    mov    %rsp,%r13
 9│    0x0000000000401103 <+15>:    mov    %rsp,%rsi
10│    0x0000000000401106 <+18>:    call   0x40145c <read_six_numbers>    
11│    0x000000000040110b <+23>:    mov    %rsp,%r14              
12│    0x000000000040110e <+26>:    mov    $0x0,%r12d             

// loop_1: 6个数字各不相等
13│    0x0000000000401114 <+32>:    mov    %r13,%rbp                        
14│    0x0000000000401117 <+35>:    mov    0x0(%r13),%eax         
15│    0x000000000040111b <+39>:    sub    $0x1,%eax              
16│    0x000000000040111e <+42>:    cmp    $0x5,%eax
17│    0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>
18│    0x0000000000401123 <+47>:    call   0x40143a <explode_bomb>
19│    0x0000000000401128 <+52>:    add    $0x1,%r12d
20│    0x000000000040112c <+56>:    cmp    $0x6,%r12d
21│    0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
22│    0x0000000000401132 <+62>:    mov    %r12d,%ebx

23│    0x0000000000401135 <+65>:    movslq %ebx,%rax
24│    0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax
25│    0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)
26│    0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
27│    0x0000000000401140 <+76>:    call   0x40143a <explode_bomb>
28│    0x0000000000401145 <+81>:    add    $0x1,%ebx
29│    0x0000000000401148 <+84>:    cmp    $0x5,%ebx
30│    0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>

31│    0x000000000040114d <+89>:    add    $0x4,%r13
32│    0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
// end loop_1

33│    0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi
34│    0x0000000000401158 <+100>:   mov    %r14,%rax
35│    0x000000000040115b <+103>:   mov    $0x7,%ecx

// loop_2: 求7-所有数
36│    0x0000000000401160 <+108>:   mov    %ecx,%edx
37│    0x0000000000401162 <+110>:   sub    (%rax),%edx
38│    0x0000000000401164 <+112>:   mov    %edx,(%rax)
39│    0x0000000000401166 <+114>:   add    $0x4,%rax
40│    0x000000000040116a <+118>:   cmp    %rsi,%rax
41│    0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>
// end loop_2

42│    0x000000000040116f <+123>:   mov    $0x0,%esi
43│    0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>

// loop_3: 寻找处理后的数组对应的node地址，写入栈
// 大于1时: 找到rcx对应的node_2~6地址保存在rdx里
44│    0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx
45│    0x000000000040117a <+134>:   add    $0x1,%eax
46│    0x000000000040117d <+137>:   cmp    %ecx,%eax
47│    0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>
48│    0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>

// 小于等于1时: 使用node_1
49│    0x0000000000401183 <+143>:   mov    $0x6032d0,%edx  // node_1

// 向栈指针+20字开始逐个写入对应node的地址
50│    0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)
51│    0x000000000040118d <+153>:   add    $0x4,%rsi
52│    0x0000000000401191 <+157>:   cmp    $0x18,%rsi
53│    0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>
// 逐个访问数组保存在rcx里
54│    0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx
55│    0x000000000040119a <+166>:   cmp    $0x1,%ecx
56│    0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>

57│    0x000000000040119f <+171>:   mov    $0x1,%eax
58│    0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx
59│    0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>
// end loop_3

60│    0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx
61│    0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax // rax = arr[1]对应node
62│    0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi // nodes右边界
63│    0x00000000004011ba <+198>:   mov    %rbx,%rcx       // arr[0]对应node

// loop_4: 按照arr对应顺序重整链表
64│    0x00000000004011bd <+201>:   mov    (%rax),%rdx
65│    0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx) // rcx.next = rdx
66│    0x00000000004011c4 <+208>:   add    $0x8,%rax // rax = arr[i + 1]对应node
67│    0x00000000004011c8 <+212>:   cmp    %rsi,%rax
68│    0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
69│    0x00000000004011cd <+217>:   mov    %rdx,%rcx
70│    0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
// end loop_4

71│    0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx) // last_node.next = NULL;
72│    0x00000000004011da <+230>:   mov    $0x5,%ebp

// 遍历链表，检查是否递减
73│    0x00000000004011df <+235>:   mov    0x8(%rbx),%rax // %rbx保存arr[0]对应node地址
74│    0x00000000004011e3 <+239>:   mov    (%rax),%eax // rax = rbx.next.val
75│    0x00000000004011e5 <+241>:   cmp    %eax,(%rbx) // rbx.next.val <= rbx.val
76│    0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>
77│    0x00000000004011e9 <+245>:   call   0x40143a <explode_bomb>
78│    0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx
79│    0x00000000004011f2 <+254>:   sub    $0x1,%ebp
80│    0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>

81│    0x00000000004011f7 <+259>:   add    $0x50,%rsp
82│    0x00000000004011fb <+263>:   pop    %rbx
83│    0x00000000004011fc <+264>:   pop    %rbp
84│    0x00000000004011fd <+265>:   pop    %r12
85│    0x00000000004011ff <+267>:   pop    %r13
86│    0x0000000000401201 <+269>:   pop    %r14
87│    0x0000000000401203 <+271>:   ret
88│ End of assembler dump.

